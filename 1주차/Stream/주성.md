## **Q. Java Stream에 대해 설명해 주세요.**

- Stream은 Java 8에서 소개된 API로, 데이터의 흐름을 처리하는데 편리합니다. 
- 컬렉션, 배열 등의 데이터 소스를 효율적으로 처리할 수 있는 API를 제공합니다. 
- Stream은 중간 연산(필터링, 매핑 등)과 최종 연산(결과를 생산하는 연산, 예: 합계, 평균, 카운트 등)으로 구성되며, 이를 통해 람다 표현식과 같은 함수형 프로그래밍 스타일을 지원합니다.

## **Q. Stream과 for ~ loop의 성능 차이를 비교해 주세요**

- 일반적으로, for loop와 stream의 성능은 비슷하며 상황에 따라 다를 수 있습니다. 
- 작은 데이터 세트에서는 성능 차이가 거의 없지만, 매우 큰 데이터 세트에서는 stream의 병렬 처리 능력이 큰 장점이 될 수 있습니다.
- 또한, 개인적으로는 선언적 형태가 가독성이 더 좋다고 생각합니다.

### **Q. Stream은 병렬처리 할 수 있나요?**

- Stream은 병렬 처리를 지원합니다. 
- **`parallelStream()`** 메서드를 사용하거나, 기존의 stream에 **`parallel()`** 메서드를 호출하면, 데이터가 여러 스레드에서 병렬로 처리됩니다. 
- 이는 특히 큰 데이터 세트에서 유용하지만, 모든 상황에서 효율적인 것은 아닙니다. 
- 동기화 등의 이슈로 인해 병렬 스트림이 오히려 성능을 저하시킬 수도 있습니다.

### **Q. Stream에서 사용할 수 있는 함수형 인터페이스에 대해 설명해 주세요.**

- Stream API는 여러 함수형 인터페이스를 사용합니다. 
- 대표적으로는 **`Predicate`**, **`Function`**, **`Consumer`**, **`Supplier`** 등이 있습니다.

- **`Predicate<T>`**: T 타입의 객체를 인수로 받아 boolean 값을 리턴하는 함수입니다.
- **`Function<T, R>`**: T 타입의 객체를 인수로 받아 R 타입의 객체를 리턴하는 함수입니다.
- **`Consumer<T>`**: T 타입의 객체를 인수로 받아 리턴값 없이 실행하는 함수입니다.
- **`Supplier<T>`**: 인수 없이 T 타입의 객체를 리턴하는 함수입니다.

### **Q. 가끔 외부 변수를 사용할 때, final 키워드를 붙여서 사용하는데 왜 그럴까요? 꼭 그래야 할까요?**

- 외부 변수를 사용할 때 final 키워드를 붙이는 이유는 람다 표현식 내부에서 참조하는 외부 변수가 실질적으로 final이어야 함을 보장하기 위해서입니다. 
- 이는 람다 표현식이 병렬 실행될 때의 안정성을 위해 필요한 제약입니다.
- Java 8 이전에는 내부 클래스나 무명 클래스에서 외부 변수를 사용할 때 그 변수가 `final`이어야 했습니다. 
- 이는 변수가 실질적으로 한 번만 할당됨을 보장하므로, 다중 스레드 환경에서 일관성 문제를 방지합니다. 
- Java 8부터는 'effective final'이라는 개념이 도입되어, `final` 키워드를 생략해도 실질적으로 `final`인 변수는 람다 표현식에서 사용할 수 있게 되었습니다